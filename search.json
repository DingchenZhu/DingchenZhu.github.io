[{"title":"c++_stl","url":"/2025/06/27/c-stl/","content":"Notes for C++ STL\nAbout RefAbout Structstruct Point()&#123;    int x, y;    Point (int x=0, int y=0) : x(x), y(y) &#123;&#125; // constructor function    //this-&gt;x = x; this-&gt;y = y;&#125;;Point operator + (const Point&amp; A, const Point&amp; B)&#123;    return Point(A.x+B.x, A.y+B.y);&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Point&amp; p)&#123;    return out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;&#125;\nAbout Templatetemplate&lt;typename T&gt;//for the code abovestruct Point()&#123;    T x, y;    Point (T x=0, T y=0) : x(x), y(y) &#123;&#125; &#125;;template&lt;typename T&gt;Point&lt;T&gt; operator + (const Point&lt;T&gt;&amp; A, const Point&lt;T&gt;&amp; B)&#123;    return Point&lt;T&gt;(A.x+B.x, A.y+B.y);&#125;// The following recall should be ...// Point&lt;double&gt; xxx, Point&lt;int&gt; xxx\nAbout STLContainerVectorvector&lt;int&gt; v = &#123;1,2,3,4,5&#125;;// Delete the last value in the vectorv.pop_back();// Find a value in a vectorauto it = find(v.begin(), v.end(), 3);// Sort a vectorsort(v.begin(), v.end());// Reverse a vectorreverse(v.begin(), v.end());// Remove a value in a vectorv.erase(remove(v.begin(), v.end(), 3), v.end());// Find a value which not less than xauto it = lower_bound(v.begin(), v.end(), 3);// Find a value which not greater than xauto it = upper_bound(v.begin(), v.end(), 3);\nListlist&lt;int&gt; l = &#123;1,2,3,4,5&#125;;// Bidirectional iteratorpush_back(const T&amp; value), pop_back(), push_front(const T&amp; value), pop_front()advance(iterator, n), distance(iterator1, iterator2) l.unique() // remove the same value in the list\nSetunordered_set&lt;Key, Hash = std::hash&lt;Key&gt;, Pred = std::equal_to&lt;Key&gt;, Alloc = std::allocator&lt;Key&gt;&gt;unordered_set&lt;int&gt; s = &#123;1,2,3,4,5&#125;;s.insert(3); // insert a values.erase(3); // remove a values.find(3); // find a value\nMapmap&lt;key_type, value_type&gt; m = &#123;&#123;1,2&#125;, &#123;3,4&#125;, &#123;5,6&#125;&#125;;m[key] = value; // insert a valuevalue = m[key]; // find a valueunordered_map&lt;key_type, value_type&gt; myMap;myMap.insert(pair&lt;int, int&gt;(1, 2));\n\n\nQueuequeue&lt;int&gt; q;q.push(1);q.pop();q.front();q.back();\nStackstack&lt;int&gt; s;s.push(1);s.pop();s.top();\nIteratorfor(ContainerType::iterator it = c.begin(); it != c.end(); it++)\nAlgorithm//Sortsort(container.begin(), container.end(),compare_function)partial_sort(container.begin(), container.begin()+k, container.end(), compare_function)stable_sort(container.begin(), container.end(), compare_function)//Findauto it = find(container.begin(), container.end(), value)binary_search(container.begin(), container.end(), value)auto it = find_if(vec.begin(), vec.end(), [](int x) &#123; return x &gt; 3; &#125;);//Copycopy(source_begin, source_end, destination_begin)//Mergemerge(source1_begin, source1_end, source2_begin, source2_end, destination_begin)//For_eachfor_each(vec.begin(), vec.end(), [](int&amp; x) &#123; x += 1; &#125;);\n\n"},{"title":"leetcode","url":"/2025/06/27/leetcode/","content":"Leetcode1. Sliding Window// 1. Sliding Window with fixed size// 1456 Maximum Number of Vowels in a Substring of Given Length// 1. Enter the windowfor(int i = 0; i &lt; s.length(); i++)&#123;    if(s[i] == &#x27;a&#x27; || s[i] == &#x27;e&#x27; || s[i] == &#x27;i&#x27; || s[i] == &#x27;o&#x27; || s[i] == &#x27;u&#x27;)&#123;        vowel++;    &#125;    if(i &lt; k - 1) &#123;        continue; // Not enough characters to form a window    &#125;    // 2. Update the answer    ans = max(ans, vowel);    // 3. Slide the window    char out = s[i - k + 1];    if(out == &#x27;a&#x27; || out == &#x27;e&#x27; || out == &#x27;i&#x27; || out == &#x27;o&#x27; || out == &#x27;u&#x27;)&#123;        vowel--;    &#125;&#125;//2841 Maximum Number of Subsequences with nearly the onlylong long maxSum(vector&lt;int&gt;&amp; nums, int m, int k) &#123;    long long sum = 0;    long long ans = 0;    unordered_map&lt;int, int&gt; countMap;    for( int i = 0; i &lt; nums.size(); i++)&#123;        sum += nums[i];        countMap[nums[i]]++;        if(i &lt; k - 1) &#123;            continue;        &#125;        if(countMap.size() &gt;= m)&#123;    ans = max(ans, sum); &#125;        sum -= nums[i - k + 1];        if(--countMap[nums[i - k + 1]] == 0) &#123;            countMap.erase(nums[i - k + 1]);        &#125;    &#125;    return ans;&#125;// The conversion for the problem// 3439 The arrangement of the conferenceint n = startTime.size();\tvector&lt;int&gt; space(n + 1);\tspace[0] = startTime[0];\tfor(int i = 1 ; i &lt; n; ++i) &#123;\t\tspace[i] = startTime[i] - endTime[i - 1];\t&#125;\tint ans = 0, sum = 0;\tspace[n] = eventTime - endTime[n - 1];\tfor(int i = 0; i &lt;= n; i++)&#123;\t\tsum += space[i];\t\tif(i &lt; k)&#123;continue;&#125;\t\tans = max(ans, sum);\t\tsum -= space[i - k];\t&#125;return ans;//2. Window with variable size//3 The max length of  substringfor(lp = 0; lp &lt; n; lp++)&#123;    while( rp &lt; n-1 &amp;&amp; !charSet.count(s[rp+1]))&#123;        charSet.insert(s[++rp]);    &#125;    ans = max(ans, rp - lp + 1);    charSet.erase(s[lp]);&#125; // Use two pointers to track the window// 3090 ... Use the unordered_map to track the charSetfor(left = 0; left &lt; n; left++)&#123;    while( right + 1 &lt; n &amp;&amp; charSet[s[right+1]] &lt; 2)&#123; charSet[s[++right]]++;&#125;        ans = max(ans, right - left + 1);        charSet[s[left]]--;    &#125;// Use the two pointers to maintain the windowfor( right = 0; right &lt; n; right++)&#123;    cnt_0 += 1- nums[right];    if( cnt_0 &gt; 1)&#123;        cnt_0 -= 1 - nums[left++];    &#125;    ans = max(ans, right - left);&#125;// 904 Fruit in the Basketfor( right = 0; right &lt; n; right++)&#123;    fruitCount[fruits[right]]++;    while( fruitCount.size() &gt; 2)&#123;        fruitCount[fruits[left]]--;        if(fruitCount[fruits[left]] == 0)&#123;    fruitCount.erase(fruits[left]); &#125;        left ++;        &#125;        ans = max(ans, right - left + 1);    &#125;// 2024 The perplexity of the examfor( right = 0; right &lt; n; right++)&#123;    count[answerKey[right]]++;    while(count[&#x27;T&#x27;] &gt; k &amp;&amp; count[&#x27;F&#x27;] &gt; k) &#123;        count[answerKey[left]]--;        left++;    &#125;    ans = max(ans, right - left + 1);&#125;// 1658 Minimum Operations to Reduce X to Zeroint target = reduce(nums.begin(), nums.end()) - x;if(target &lt; 0) return -1;int left = 0, right = 0, ans = -1, sum = 0;for( right = 0 ; right &lt; nums.size(); right++)&#123;    sum += nums[right];    while(sum &gt; target)&#123;    sum -= nums[left++];    &#125;    if(sum == target)    ans = max(ans, right - left + 1);&#125;return ans &lt; 0 ? -1: nums.size() - ans;// 2730 find the max length of half-duplicated stringfor( right = 1; right &lt; n; right++)&#123;    if(s[right] == s[right-1])&#123;    flag ++;     &#125;    if( flag &gt; 1)&#123;        while( s[left] != s[left+1])&#123;    left++;    &#125;        left ++;        flag = 1;        &#125;    ans = max(ans, right - left + 1);&#125;//1838 Frequency of the Most Frequent Elementfor(right = 1; right &lt; n; right ++)&#123;    sum += (long long)(nums[right]-nums[right - 1]) * (right - left);    while( sum &gt; k)&#123;        sum -= (nums[right] - nums[left]);                left++;    &#125;    ans = max(ans, right - left + 1);&#125;// So tired...\n\n2. Dual Pointer// 125 Valid Palindromeint left = 0, right = s.size() - 1;while( left &lt; right )&#123;    while( left &lt; right &amp;&amp; !isalnum(s[left]) ) left++;    while( left &lt; right &amp;&amp; !isalnum(s[right]) ) right--;    if( tolower(s[left]) != tolower(s[right]) ) return false;    left++;    right--;&#125;return true;// 15 3Sumfor(int i = 0; i &lt; nums.size()-2; i++)&#123;    int x = nums[i];    if(i&gt;0 &amp;&amp; x==nums[i-1])    continue;    int left = i+1;    int right = nums.size()-1;      while(left&lt;right)&#123;        int s = x+nums[left]+nums[right];        if( s&gt;0)   right--;        else if( s&lt;0)   left++;        else &#123;             ans.push_back(&#123;x,nums[left++],nums[right--]&#125;);             for(left;left&lt;right &amp;&amp; nums[left]==nums[left-1];left++);            for(right;right&gt;left &amp;&amp; nums[right]==nums[right+1];right--);        &#125;    &#125;&#125;// 42 Trapping Rain Watervector&lt;int&gt; pre_height(n);vector&lt;int&gt; suf_height(n);pre_height[0] = height[0];for(int i = 1; i &lt; n; i++)&#123;    pre_height[i] = max(pre_height[i-1],height[i]);&#125;suf_height[n-1] = height[n-1];for(int j = n-2; j &gt;=0; j--)&#123;    suf_height[j] = max(height[j],suf_height[j+1]);&#125;int sum = 0;for(int i = 0; i &lt; n; i ++)&#123;    sum += min(pre_height[i],suf_height[i]) - height[i];&#125;//560 Subarray Sum Equals Kvector&lt;int&gt; pre_sum(nums.size()+1);pre_sum[0] = 0;for(int i = 0; i &lt; nums.size(); i++)&#123;    pre_sum[i+1] = pre_sum[i] + nums[i];&#125; unordered_map&lt;int, int&gt; m;int ans = 0;for(int p:pre_sum)&#123;    ans += m.contains(p-k)?m[p-k]:0;    m[p]++;&#125;\n3. Linked List//160 Intersection of Two Linked ListsListNode* pa = headA;ListNode* pb = headB;if(pa == NULL || pb == NULL)    return NULL;while(pa != pb)&#123;    pa = pa ? pa-&gt;next : headB;    pb = pb ? pb-&gt;next : headA;&#125;return pa;//206 Reverse Linked Listwhile(cur)&#123;    ListNode* next = cur-&gt;next;    cur-&gt;next = pre;    pre = cur;    cur = next;&#125;// 141 Linked List CycleListNode* slow = head;ListNode* fast = head-&gt;next ;while(slow != fast)&#123;    if(fast == NULL || fast-&gt;next == NULL)  return false;    slow = slow-&gt;next;    fast = fast-&gt;next-&gt;next;&#125;// 142 Linked List Cycle IIListNode* fast = head;ListNode* slow = head;while(fast &amp;&amp; fast-&gt;next)&#123;    slow = slow-&gt;next;    fast = fast-&gt;next-&gt;next;    if(fast == slow)&#123;        while(head != slow)&#123;            head = head-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;\n4. DP// 70 Climbing Stairsint p = 0, q = 0, r = 1;for(int i = 1; i &lt;= n; i++)&#123;    p = q;    q = r;    r = p+q;&#125;//746 Min Cost Climbing Stairsvector&lt;int&gt; dp(n+1);dp[0] = dp[1] = 0;for(int i = 2; i &lt; n+1; i++)&#123;    dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);&#125;//198 House Robberif(n == 1)  return nums[0];dp[0] = nums[0];dp[1] = max(nums[0],nums[1]);for(int i = 2; i &lt; n; i++)&#123;    dp[i] = max(dp[i-1], dp[i-2]+nums[i]);&#125;return dp[n-1];//377 Combination Sum IVfor(int i = 1; i &lt;= target; i++)&#123;    for(int x:nums)&#123;        if(x &lt;= i)            dp[i] += dp[i-x];    &#125;&#125;return dp[target];\nFor climbing stairs, we can use the following formula to calculate the number of ways to climb to the top( if given the nums):$$f(i) &#x3D; \\sum_{j &#x3D; 0}^{nums.size()-1}f(i-nums[j])$$\n// 2466 The good stringdp[0] = 1;for(int i = 1; i &lt;= high; i++)&#123;    if(zero &lt;= i)   dp[i] = dp[i-zero];    if(one &lt;= i)    dp[i] = (dp[i] +dp[i-one]) % MOD;        &#125;for(int j = low; j &lt;= high; j++)&#123;    ans = (ans + dp[j]) % MOD;&#125;// 139 Word Breakfor(int i = 1; i &lt;= n; i++)&#123;    for(int j = 0; j &lt; i ;j ++)&#123;        if(dp[j] &amp;&amp; st.find(s.substr(j, i-j))!= st.end())&#123;            dp[i] = true;            break;        &#125;    &#125;&#125;\n5. Tree//94 Binary Tree Inorder Traversal (recursion)void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;        if(!root)   return;        inorder(root-&gt;left,res);        res.push_back(root-&gt;val);        inorder(root-&gt;right,res);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        inorder(root,res);        return res;&#125;//(iterative) Use the stackstack&lt;TreeNode*&gt; st;while(root || !st.empty())&#123;    while(root)&#123;        st.push(root);        root = root-&gt;left;    &#125;    root = st.top();    st.pop();    ans.push_back(root-&gt;val);    root = root-&gt;right;&#125;"},{"title":"Welcome to use Hexo Theme Keep","url":"/2022/10/25/welcome-to-use-hexo-theme-keep/","content":"Welcome to use Hexo Theme Keep.\nThis is your very first post. Check documentation for more info. If you get any problems when using Keep theme, you can ask me on GitHub.\n\n\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo","Keep"]},{"title":"rust_for_rcore","url":"/2025/07/01/rust-for-rcore/","content":"Rust_for_rcoreRust basisOwnershipfn main() &#123;    let s = String::from(&quot;hello&quot;);    take_ownership(s); // s&#x27;s value moves into the function...and no more valid in this scope    // println!(&quot;&#123;&#125;&quot;, s); // error: value used here after move    // two ways to mend this error    // 1. take_ownership(s.clone())    // 2. fn take_ownership(some_string: &amp;String) &#123;...&#125; then in main() take_ownership(&amp;s)    // for integer    let x = 5;    makes_copy(x); // x would move into the function, but i32 is Copy, so it&#x27;s okay to still use x afterward    // return value    let s1 = gives_ownership(); // gives_ownership moves its return value into s1    let s2 = String::from(&quot;hello&quot;); // s2 comes into scope    let s3 = takes_and_gives_back(s2); // s2 is moved into takes_and_gives_back, which also moves its return value into s3    // borrow    let s1 = String::from(&quot;hello&quot;);    let len = calculate_length(&amp;s1); // &amp;s1 borrows the String    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);&#125;   fn take_ownership(some_string: String) &#123;     println!(&quot;&#123;&#125;&quot;, some_string);&#125;```     ### Type```rust// Structstruct User &#123;    username: String,    email: String,    sign_in_count: u64,    active: bool,&#125;// Tuple structstruct Color(i32, i32, i32);// Vectorlet v: Vec&lt;i32&gt; = Vec::new();let v = vec![1, 2, 3]; // [1, 2, 3]// HashMapuse std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(&quot;Blue&quot;), 10);let team_name = String::from(&quot;Blue&quot;);// Enumenum Message &#123;    Quit,    Move &#123; x: i32, y: i32 &#125;,    Write(String),    ChangeColor(i32, i32, i32),&#125;// Optionenum Option&lt;T&gt; &#123;    Some(T),    None,&#125;let some_number = Some(5);let some_string = Some(&quot;a string&quot;);let absent_number: Option&lt;i32&gt; = None;//matchfn value_in_cents(coin: Coin) -&gt; u8 &#123;    match coin &#123;        Coin::Penny =&gt; &#123;            println!(&quot;Lucky penny!&quot;);            1        &#125;,        Coin::Nickel =&gt; 5,        Coin::Dime =&gt; 10,        Coin::Quarter =&gt; 25,    &#125;&#125;"}]