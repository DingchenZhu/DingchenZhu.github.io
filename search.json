[{"title":"c++_stl","url":"/2025/06/27/c-stl/","content":"Notes for C++ STL\nAbout RefAbout Structstruct Point()&#123;    int x, y;    Point (int x=0, int y=0) : x(x), y(y) &#123;&#125; // constructor function    //this-&gt;x = x; this-&gt;y = y;&#125;;Point operator + (const Point&amp; A, const Point&amp; B)&#123;    return Point(A.x+B.x, A.y+B.y);&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Point&amp; p)&#123;    return out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;&#125;\nAbout Templatetemplate&lt;typename T&gt;//for the code abovestruct Point()&#123;    T x, y;    Point (T x=0, T y=0) : x(x), y(y) &#123;&#125; &#125;;template&lt;typename T&gt;Point&lt;T&gt; operator + (const Point&lt;T&gt;&amp; A, const Point&lt;T&gt;&amp; B)&#123;    return Point&lt;T&gt;(A.x+B.x, A.y+B.y);&#125;// The following recall should be ...// Point&lt;double&gt; xxx, Point&lt;int&gt; xxx\nAbout STLContainerVectorvector&lt;int&gt; v = &#123;1,2,3,4,5&#125;;// Delete the last value in the vectorv.pop_back();// Find a value in a vectorauto it = find(v.begin(), v.end(), 3);// Sort a vectorsort(v.begin(), v.end());// Reverse a vectorreverse(v.begin(), v.end());// Remove a value in a vectorv.erase(remove(v.begin(), v.end(), 3), v.end());// Find a value which not less than xauto it = lower_bound(v.begin(), v.end(), 3);// Find a value which not greater than xauto it = upper_bound(v.begin(), v.end(), 3);\nListlist&lt;int&gt; l = &#123;1,2,3,4,5&#125;;// Bidirectional iteratorpush_back(const T&amp; value), pop_back(), push_front(const T&amp; value), pop_front()advance(iterator, n), distance(iterator1, iterator2) l.unique() // remove the same value in the list\nSetunordered_set&lt;Key, Hash = std::hash&lt;Key&gt;, Pred = std::equal_to&lt;Key&gt;, Alloc = std::allocator&lt;Key&gt;&gt;unordered_set&lt;int&gt; s = &#123;1,2,3,4,5&#125;;s.insert(3); // insert a values.erase(3); // remove a values.find(3); // find a value\nMapmap&lt;key_type, value_type&gt; m = &#123;&#123;1,2&#125;, &#123;3,4&#125;, &#123;5,6&#125;&#125;;m[key] = value; // insert a valuevalue = m[key]; // find a valueunordered_map&lt;key_type, value_type&gt; myMap;myMap.insert(pair&lt;int, int&gt;(1, 2));\n\n\nQueuequeue&lt;int&gt; q;q.push(1);q.pop();q.front();q.back();\nStackstack&lt;int&gt; s;s.push(1);s.pop();s.top();\nIteratorfor(ContainerType::iterator it = c.begin(); it != c.end(); it++)\nAlgorithm//Sortsort(container.begin(), container.end(),compare_function)partial_sort(container.begin(), container.begin()+k, container.end(), compare_function)stable_sort(container.begin(), container.end(), compare_function)//Findauto it = find(container.begin(), container.end(), value)binary_search(container.begin(), container.end(), value)auto it = find_if(vec.begin(), vec.end(), [](int x) &#123; return x &gt; 3; &#125;);//Copycopy(source_begin, source_end, destination_begin)//Mergemerge(source1_begin, source1_end, source2_begin, source2_end, destination_begin)//For_eachfor_each(vec.begin(), vec.end(), [](int&amp; x) &#123; x += 1; &#125;);\n\n"},{"title":"leetcode","url":"/2025/06/27/leetcode/","content":"Leetcode1. Sliding Window// 1. Sliding Window with fixed size// 1456 Maximum Number of Vowels in a Substring of Given Length// 1. Enter the windowfor(int i = 0; i &lt; s.length(); i++)&#123;    if(s[i] == &#x27;a&#x27; || s[i] == &#x27;e&#x27; || s[i] == &#x27;i&#x27; || s[i] == &#x27;o&#x27; || s[i] == &#x27;u&#x27;)&#123;        vowel++;    &#125;    if(i &lt; k - 1) &#123;        continue; // Not enough characters to form a window    &#125;    // 2. Update the answer    ans = max(ans, vowel);    // 3. Slide the window    char out = s[i - k + 1];    if(out == &#x27;a&#x27; || out == &#x27;e&#x27; || out == &#x27;i&#x27; || out == &#x27;o&#x27; || out == &#x27;u&#x27;)&#123;        vowel--;    &#125;&#125;//2841 Maximum Number of Subsequences with nearly the onlylong long maxSum(vector&lt;int&gt;&amp; nums, int m, int k) &#123;    long long sum = 0;    long long ans = 0;    unordered_map&lt;int, int&gt; countMap;    for( int i = 0; i &lt; nums.size(); i++)&#123;        sum += nums[i];        countMap[nums[i]]++;        if(i &lt; k - 1) &#123;            continue;        &#125;        if(countMap.size() &gt;= m)&#123;    ans = max(ans, sum); &#125;        sum -= nums[i - k + 1];        if(--countMap[nums[i - k + 1]] == 0) &#123;            countMap.erase(nums[i - k + 1]);        &#125;    &#125;    return ans;&#125;// The conversion for the problem// 3439 The arrangement of the conferenceint n = startTime.size();\tvector&lt;int&gt; space(n + 1);\tspace[0] = startTime[0];\tfor(int i = 1 ; i &lt; n; ++i) &#123;\t\tspace[i] = startTime[i] - endTime[i - 1];\t&#125;\tint ans = 0, sum = 0;\tspace[n] = eventTime - endTime[n - 1];\tfor(int i = 0; i &lt;= n; i++)&#123;\t\tsum += space[i];\t\tif(i &lt; k)&#123;continue;&#125;\t\tans = max(ans, sum);\t\tsum -= space[i - k];\t&#125;return ans;//2. Window with variable size//3 The max length of  substringfor(lp = 0; lp &lt; n; lp++)&#123;    while( rp &lt; n-1 &amp;&amp; !charSet.count(s[rp+1]))&#123;        charSet.insert(s[++rp]);    &#125;    ans = max(ans, rp - lp + 1);    charSet.erase(s[lp]);&#125; // Use two pointers to track the window// 3090 ... Use the unordered_map to track the charSetfor(left = 0; left &lt; n; left++)&#123;    while( right + 1 &lt; n &amp;&amp; charSet[s[right+1]] &lt; 2)&#123; charSet[s[++right]]++;&#125;        ans = max(ans, right - left + 1);        charSet[s[left]]--;    &#125;// Use the two pointers to maintain the windowfor( right = 0; right &lt; n; right++)&#123;    cnt_0 += 1- nums[right];    if( cnt_0 &gt; 1)&#123;        cnt_0 -= 1 - nums[left++];    &#125;    ans = max(ans, right - left);&#125;// 904 Fruit in the Basketfor( right = 0; right &lt; n; right++)&#123;    fruitCount[fruits[right]]++;    while( fruitCount.size() &gt; 2)&#123;        fruitCount[fruits[left]]--;        if(fruitCount[fruits[left]] == 0)&#123;    fruitCount.erase(fruits[left]); &#125;        left ++;        &#125;        ans = max(ans, right - left + 1);    &#125;// 2024 The perplexity of the examfor( right = 0; right &lt; n; right++)&#123;    count[answerKey[right]]++;    while(count[&#x27;T&#x27;] &gt; k &amp;&amp; count[&#x27;F&#x27;] &gt; k) &#123;        count[answerKey[left]]--;        left++;    &#125;    ans = max(ans, right - left + 1);&#125;// 1658 Minimum Operations to Reduce X to Zeroint target = reduce(nums.begin(), nums.end()) - x;if(target &lt; 0) return -1;int left = 0, right = 0, ans = -1, sum = 0;for( right = 0 ; right &lt; nums.size(); right++)&#123;    sum += nums[right];    while(sum &gt; target)&#123;    sum -= nums[left++];    &#125;    if(sum == target)    ans = max(ans, right - left + 1);&#125;return ans &lt; 0 ? -1: nums.size() - ans;// 2730 find the max length of half-duplicated stringfor( right = 1; right &lt; n; right++)&#123;    if(s[right] == s[right-1])&#123;    flag ++;     &#125;    if( flag &gt; 1)&#123;        while( s[left] != s[left+1])&#123;    left++;    &#125;        left ++;        flag = 1;        &#125;    ans = max(ans, right - left + 1);&#125;//1838 Frequency of the Most Frequent Elementfor(right = 1; right &lt; n; right ++)&#123;    sum += (long long)(nums[right]-nums[right - 1]) * (right - left);    while( sum &gt; k)&#123;        sum -= (nums[right] - nums[left]);                left++;    &#125;    ans = max(ans, right - left + 1);&#125;// So tired...\n\n2. Dual Pointer// 125 Valid Palindromeint left = 0, right = s.size() - 1;while( left &lt; right )&#123;    while( left &lt; right &amp;&amp; !isalnum(s[left]) ) left++;    while( left &lt; right &amp;&amp; !isalnum(s[right]) ) right--;    if( tolower(s[left]) != tolower(s[right]) ) return false;    left++;    right--;&#125;return true;// 15 3Sumfor(int i = 0; i &lt; nums.size()-2; i++)&#123;    int x = nums[i];    if(i&gt;0 &amp;&amp; x==nums[i-1])    continue;    int left = i+1;    int right = nums.size()-1;      while(left&lt;right)&#123;        int s = x+nums[left]+nums[right];        if( s&gt;0)   right--;        else if( s&lt;0)   left++;        else &#123;             ans.push_back(&#123;x,nums[left++],nums[right--]&#125;);             for(left;left&lt;right &amp;&amp; nums[left]==nums[left-1];left++);            for(right;right&gt;left &amp;&amp; nums[right]==nums[right+1];right--);        &#125;    &#125;&#125;// 42 Trapping Rain Watervector&lt;int&gt; pre_height(n);vector&lt;int&gt; suf_height(n);pre_height[0] = height[0];for(int i = 1; i &lt; n; i++)&#123;    pre_height[i] = max(pre_height[i-1],height[i]);&#125;suf_height[n-1] = height[n-1];for(int j = n-2; j &gt;=0; j--)&#123;    suf_height[j] = max(height[j],suf_height[j+1]);&#125;int sum = 0;for(int i = 0; i &lt; n; i ++)&#123;    sum += min(pre_height[i],suf_height[i]) - height[i];&#125;//560 Subarray Sum Equals Kvector&lt;int&gt; pre_sum(nums.size()+1);pre_sum[0] = 0;for(int i = 0; i &lt; nums.size(); i++)&#123;    pre_sum[i+1] = pre_sum[i] + nums[i];&#125; unordered_map&lt;int, int&gt; m;int ans = 0;for(int p:pre_sum)&#123;    ans += m.contains(p-k)?m[p-k]:0;    m[p]++;&#125;\n3. Linked List//160 Intersection of Two Linked ListsListNode* pa = headA;ListNode* pb = headB;if(pa == NULL || pb == NULL)    return NULL;while(pa != pb)&#123;    pa = pa ? pa-&gt;next : headB;    pb = pb ? pb-&gt;next : headA;&#125;return pa;//206 Reverse Linked Listwhile(cur)&#123;    ListNode* next = cur-&gt;next;    cur-&gt;next = pre;    pre = cur;    cur = next;&#125;// 141 Linked List CycleListNode* slow = head;ListNode* fast = head-&gt;next ;while(slow != fast)&#123;    if(fast == NULL || fast-&gt;next == NULL)  return false;    slow = slow-&gt;next;    fast = fast-&gt;next-&gt;next;&#125;// 142 Linked List Cycle IIListNode* fast = head;ListNode* slow = head;while(fast &amp;&amp; fast-&gt;next)&#123;    slow = slow-&gt;next;    fast = fast-&gt;next-&gt;next;    if(fast == slow)&#123;        while(head != slow)&#123;            head = head-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;\n4. DP// 70 Climbing Stairsint p = 0, q = 0, r = 1;for(int i = 1; i &lt;= n; i++)&#123;    p = q;    q = r;    r = p+q;&#125;//746 Min Cost Climbing Stairsvector&lt;int&gt; dp(n+1);dp[0] = dp[1] = 0;for(int i = 2; i &lt; n+1; i++)&#123;    dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);&#125;//198 House Robberif(n == 1)  return nums[0];dp[0] = nums[0];dp[1] = max(nums[0],nums[1]);for(int i = 2; i &lt; n; i++)&#123;    dp[i] = max(dp[i-1], dp[i-2]+nums[i]);&#125;return dp[n-1];//377 Combination Sum IVfor(int i = 1; i &lt;= target; i++)&#123;    for(int x:nums)&#123;        if(x &lt;= i)            dp[i] += dp[i-x];    &#125;&#125;return dp[target];\nFor climbing stairs, we can use the following formula to calculate the number of ways to climb to the top( if given the nums):$$f(i) &#x3D; \\sum_{j &#x3D; 0}^{nums.size()-1}f(i-nums[j])$$\n// 2466 The good stringdp[0] = 1;for(int i = 1; i &lt;= high; i++)&#123;    if(zero &lt;= i)   dp[i] = dp[i-zero];    if(one &lt;= i)    dp[i] = (dp[i] +dp[i-one]) % MOD;        &#125;for(int j = low; j &lt;= high; j++)&#123;    ans = (ans + dp[j]) % MOD;&#125;// 139 Word Breakfor(int i = 1; i &lt;= n; i++)&#123;    for(int j = 0; j &lt; i ;j ++)&#123;        if(dp[j] &amp;&amp; st.find(s.substr(j, i-j))!= st.end())&#123;            dp[i] = true;            break;        &#125;    &#125;&#125;\n5. Tree//94 Binary Tree Inorder Traversal (recursion)void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;        if(!root)   return;        inorder(root-&gt;left,res);        res.push_back(root-&gt;val);        inorder(root-&gt;right,res);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        inorder(root,res);        return res;&#125;//(iterative) Use the stackstack&lt;TreeNode*&gt; st;while(root || !st.empty())&#123;    while(root)&#123;        st.push(root);        root = root-&gt;left;    &#125;    root = st.top();    st.pop();    ans.push_back(root-&gt;val);    root = root-&gt;right;&#125;"},{"title":"Welcome to use Hexo Theme Keep","url":"/2022/10/25/welcome-to-use-hexo-theme-keep/","content":"Welcome to use Hexo Theme Keep.\nThis is your very first post. Check documentation for more info. If you get any problems when using Keep theme, you can ask me on GitHub.\n\n\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo","Keep"]},{"title":"rust_for_rcore","url":"/2025/07/01/rust-for-rcore/","content":"Rust_for_rcoreRust basisOwnershipfn main() &#123;    let s = String::from(&quot;hello&quot;);    take_ownership(s); // s&#x27;s value moves into the function...and no more valid in this scope    // println!(&quot;&#123;&#125;&quot;, s); // error: value used here after move    // two ways to mend this error    // 1. take_ownership(s.clone())    // 2. fn take_ownership(some_string: &amp;String) &#123;...&#125; then in main() take_ownership(&amp;s)    // for integer    let x = 5;    makes_copy(x); // x would move into the function, but i32 is Copy, so it&#x27;s okay to still use x afterward    // return value    let s1 = gives_ownership(); // gives_ownership moves its return value into s1    let s2 = String::from(&quot;hello&quot;); // s2 comes into scope    let s3 = takes_and_gives_back(s2); // s2 is moved into takes_and_gives_back, which also moves its return value into s3    // borrow    let s1 = String::from(&quot;hello&quot;);    let len = calculate_length(&amp;s1); // &amp;s1 borrows the String    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);&#125;   fn take_ownership(some_string: String) &#123;     println!(&quot;&#123;&#125;&quot;, some_string);&#125;```     ### Type```rust// Structstruct User &#123;    username: String,    email: String,    sign_in_count: u64,    active: bool,&#125;// Tuple structstruct Color(i32, i32, i32);// Vectorlet v: Vec&lt;i32&gt; = Vec::new();let v = vec![1, 2, 3]; // [1, 2, 3]// HashMapuse std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(&quot;Blue&quot;), 10);let team_name = String::from(&quot;Blue&quot;);// Enumenum Message &#123;    Quit,    Move &#123; x: i32, y: i32 &#125;,    Write(String),    ChangeColor(i32, i32, i32),&#125;// Optionenum Option&lt;T&gt; &#123;    Some(T),    None,&#125;let some_number = Some(5);let some_string = Some(&quot;a string&quot;);let absent_number: Option&lt;i32&gt; = None;//matchfn value_in_cents(coin: Coin) -&gt; u8 &#123;    match coin &#123;        Coin::Penny =&gt; &#123;            println!(&quot;Lucky penny!&quot;);            1        &#125;,        Coin::Nickel =&gt; 5,        Coin::Dime =&gt; 10,        Coin::Quarter =&gt; 25,    &#125;&#125;"},{"title":"Redis","url":"/2025/07/25/Redis/","content":"RedisRedis基础NoSQL非关系型数据库，数据之间没有关系，数据之间没有关系，也就没有耦合性，非常容易扩展，自由灵活，半结构化数据，没有耦合性，方便扩展，数据量大，性能高，成本低，但是没有操作接口，没有标准，没有官方支持，没有通用API，学习和使用成本较高，没有官方支持，没有表的概念，数据结构单一，但是数据操作复杂，数据完全在内存中，支持持久化背景：高并发，超大数据量，海量数据的高效率存储和访问，高可扩展性和高可用性把数据放在内存中，通过异步的方式将数据写入到硬盘，IO操作是昂贵的，内存比硬盘快10万倍分类：\n\n键值对数据库：Redis，Memcached\n列存储数据库：HBase\n文档型数据库：MongoDB\n图形数据库：Neo4j\n\nRedisRedis：Remote Dictionary Server，开源的、使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API，是跨平台的非关系型数据库\n优点：高并发读写，单线程操作缺点：ACID处理太简单，只能保证最终一致性，而且不支持回滚\nRedis6之后是多队列，多线程，但是多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行为什么不使用多线程？\n\n多线程操作需要保证原子性，但是Redis是单线程模型，操作都是原子性的\nRedis的性能瓶颈不在CPU，而在内存和网络\nRedis的瓶颈主要在网络IO，单线程可以避免频繁的上下文切换，多线程会增加CPU的消耗\nRedis的IO多路复用，多线程模型下，对于多个socket，IO多路复用只有一个线程，但是多个线程都可以去抢这个锁，对性能有影响\nRedis利用队列技术将并发访问变为串行访问，消除了线程竞争，也不存在加锁释放锁的操作，降低了开发难度，降低了开发成本\n\nRedis的Session共享：\n\nSession共享：只要保证多个应用共享同一个Session数据即可，包括共享Session数据的目的，Sessionid、Session的生命周期、Session如何实现共享\nSession共享就是通过集群，Redis实现共享\nSession共享的解决方案：\n通过Nginx负载均衡，服务器A保存Session，服务器B没有，用户跳转到服务器B时，需要重新登录\n通过Tomcat的Session复制，每台服务器都保存Session，每台服务器都有所有Session的拷贝，一台宕机，其他服务器可以继续工作，但是性能开销大\n通过Tomcat的Session集中管理，每台服务器都从Redis获取Session，每台服务器都从Redis获取Session，一台宕机，其他服务器可以继续工作，性能开销大\n通过Session粘滞，每台服务器保存自己的Session，用户每次请求都跳转到同一台服务器，一台宕机，其他服务器可以继续工作，但是性能开销大\n\n\n\n登陆缓存：使用String：侧重于查，对象转换为json字符串，使用String存储使用Hash：侧重于改，使用Hash存储\n常用命令：\nStringset key valueget keydel keysetex key seconds valuesetnx key valuettl keyincr keydecr keyincrby key incrementmset k1 v1 k2 v2mget k1 k2append key valuesetrange key offset value\nHashhset key field valuehget key fieldhexists key fieldhdel key fieldhincrby key field incrementhlen keyhkeys keyhvals keyhgetall key\nListrpush key value rpop keylrange key start stop  (0 -1)ltrim key start stop\nSetsadd key membersmembers keysrem key memberspop key countsdiff key1 key2sdiffstore destination key1 key2sinter key1 key2sunion key1 key2\nSorted Setzadd key score memberzrange key start stopzrevrange key start stopzincrby key increment memberzrank key memberzrevrank key memberzcard key \nGlobalkeys patternexpire key secondspersist keyselect indexmove key dbflushdb\n\n思考：\n\n什么时候使用Redis？需要缓存数据\n如何设计key-value？需要排序，使用Sorted Set，不需要排序，使用String （存任何数据类型，从Redis取出来的都是Objects类型）\n事务：Redis的事务没有隔离级别的概念，Redis的事务是原子性的操作，要么全部成功，要么全部失败：开始事务、命令入队、执行事务\n\n\nRedis的面试题Redis的线程模型Redis的持久化机制Redis不定时将数据写入磁盘，或者将数据追加到文件中，持久化策略：RDB、AOF，Redis启动时，会提前加载硬盘数据到内存中\n\nRDB：Redis DataBase，Redis默认的持久化机制，将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb，RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（数据丢失，版本不兼容）触发机制：save：阻塞当前Redis服务器，直到RDB文件被创建完毕bgsave：Redis会fork一个子进程来创建RDB文件，阻塞只发生在fork阶段，很快，RDB持久化保存了某个时间点的数据集，是一个非常紧凑的单一文件，Redis可以自动载入RDB文件，Redis载入RDB文件时，将文件中的数据保存到内存中，载入期间，Redis不能处理其他命令，载入期间，Redis会一直处于阻塞状态，直到载入完成，RDB文件是经过压缩的二进制文件，所以占用的空间会小于内存中的数据，更适合做备份，RDB在恢复大数据集时的速度比AOF的恢复速度要快，RDB会丢失最后一次持久化之后的数据，如果数据对于丢失不是很敏感，那么可以1天或者更久进行持久化一次，通过配置文件中的save参数来定义save m n：m是时间间隔，n是m时间内key的变化数量，save “”，禁用RDB持久化\nAOF：Append Only File，将Redis执行的每次写命令追加到文件中，AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，命令写入，append，AOF缓冲，sync，AOF文件，rewrite。。。（体积大，持久化性能相较于RDB更慢）策略：appendfsync always，每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度，appendfsync everysec，每秒钟同步一次，该策略为AOF的缺省策略，appendfsync no，从不同步，高效但是数据不会被持久化，Redis重启时会丢失数据，AOF文件会越来越大，Redis可以自动优化AOF文件\n混合持久化：Redis4.0之后新增的持久化机制，混合持久化是结合了RDB和AOF的优点，在一定程度上结合了两者的优点，混合持久化同样也是通过快照方式来提高RDB的效率，在Redis4.0之后，AOF文件加载时，优先加载AOF文件，当AOF文件加载失败，会尝试加载RDB文件，加载成功，Redis重启加载AOF文件恢复数据，加载失败，Redis重启加载RDB文件恢复数据\n\nRedis的过期策略惰性删除：只有当访问一个key时，才会判断该key是否过期，过期则删除，不删除，一直占用内存定期删除：每隔一段时间，主动地删除过期key，但是不会全盘扫描，随机抽取一部分key进行检查，判断是否过期，过期则删除，不删除，一直占用内存定时删除：为每个key设置过期时间，时间一到，立即删除，但是会占用大量CPU时间，影响性能\n实际使用：惰性删除和定期删除配合使用，Redis默认是定期删除+惰性删除，在合理使用CPU和避免浪费内存之间取得平衡\nRedis的缓存淘汰策略LFU：Least Frequently Used，最不经常使用，如果数据过去被使用得更频繁，那么将来被使用也更频繁，淘汰一定时间内被使用次数最少的数据TTL：Time To Live，设置过期时间，Redis的过期策略：定期删除、惰性删除随机删除：Redis每秒会从库中随机选择一些key，删除过期的key，如果过期key比较多，Redis会优先删除过期时间比较早的key8种：volatile，allkeys\nRedis的集群模式Redis的分布式锁加锁：setnx，设置过期时间，防止死锁执行业务：解锁：del，防止误删\nRedis的缓存穿透、缓存击穿、缓存雪崩缓存穿透：查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要去数据库查询，造成缓存穿透，解决：布隆过滤器，参数校验，缓存空值缓存击穿：某个key非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，导致数据库宕机，解决：设置热点数据永不过期，加互斥锁（双重检查DCL：进入同步之前要再查询一次，防止上一个抢到锁的线程更新了），使用分布式锁，使用Redis的setnx，使用Lua脚本缓存雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩，解决：设置过期时间时加上一个随机值\nRedis的布隆过滤器布隆过滤器：一个很长的二进制向量（位图）和一系列随机映射函数，布隆过滤器可以用于检索一个元素是否在一个集合中，优点：空间效率和查询时间都远远超过一般的算法，缺点：有一定的误识别率和删除困难，布隆过滤器可以用于解决缓存穿透问题，布隆过滤器是一个位图，位图中的每一个bit都只占一个bit\nRedis的哨兵模式哨兵模式：Redis的哨兵模式是Redis的高可用架构，哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行，其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例，哨兵有两个作用：通过发送命令，让Redis服务器返回监控其运行状态，当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机\nRedis的发布订阅Redis的PipelineRedis的Bitmap什么是bitmap：位图，bitmap就是用一个bit位来表示某个元素对应的值或者状态，从而进行统计，判断，去重，查找等操作，Redis的bitmap位图，是string数据结构的一种扩展，位图不是特殊的数据结构，它的内容其实就是普通的二进制字符串，也就是byte数组，使用位图可以用来实现布隆过滤器\nRedis的HyperLogLogRedis的GeoRedis的StreamRedis的慢查询慢查询：记录执行时间超过某个阈值（默认10毫秒）的SQL语句，慢查询日志就是记录这些SQL语句，慢查询日志可以帮助我们定位执行缓慢的SQL语句，从而进行优化，慢查询日志默认是关闭的，可以通过slowlog-log-slower-than来设置，slowlog-log-slower-than就是用来设置慢查询的时间阈值，slowlog-max-len用来设置慢查询日志最多存储多少条，slowlog-max-len默认是128，slowlog-max-len可以用来限制慢查询日志最多存储多少条\n"}]